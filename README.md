# Instant-Messaging-Application

The problem statement is to implement a secure Instant Messaging (IM) system that includes a 
client program and server program.

This report emphasizes on how we have implemented our system, the functional capabilities, 
security features, threat model, and the attacks considered while designing the system.

The requirements assume that the Server is successfully authenticated, and we need to implement 
a secure authentication channel for the clients. The objective is to build a communication protocol 
that is secure against well-known attacks on authentication, confidentiality, and integrity using 
available security primitives.

In summary, we have implemented the system in Java programming language running on the 
IntelliJ environment. We have a server program that generates private and public keys and multiple 
instances of a client program that helps run a secure communication channel using a shared session 
key generated by the server after successful authentication.

We have used AES 128-bit for the encryption of keys and messages. We take a 128-bit encrypted 
bit message, encode it to UTF-8 encoding, and then send the message to the other side. The. The 
other side decodes using the encoding and then uses the same symmetric key to decrypt the 
message.

Now let’s look at the project implementation along with their functional and security capabilities.

## Implementation

### Keys Generation
    - Every Client has its own private key, which we generate at the start of running the 
    project. The public key of the CliClient was also registered with the Server during 
    the same above run.
    - We generate the keys by running the file /src/GenerateKeys, which the keys while
    used by the main program and then generated in
    out/production/NetworkSecurity_ProjectIM/Server – public keys
    out/production/NetworkSecurity_ProjectIM/Personal – private keys

![image](https://user-images.githubusercontent.com/39727591/210395152-8cddf388-7c4c-4617-b4a0-1d65f4b319dd.png)

### Server
  - The Server now holds the responsibility of authenticating the CliClienting the keys 
generated. 
  - The Server can hold multiple sessions for different pairs of clients in parallel.
  - Once the client communication has been completed, the Server still holds the 
CliClient its authenticated list.
  - The Server generates a session key which is shared between the two requested 
clients, thereby establishing a direct communication link between them.
  - We have a function called startServer() that opens the socket to start the threads for 
clientHandlers in the file src/Server.java
  - We will look at the work in detail in point 5
![image](https://user-images.githubusercontent.com/39727591/210395356-793f3e0a-f4e5-4691-ba28-90b7a156d611.png)

### Client
  - A client can obtain a list of other clients from the Server and communicate with at 
most one of them.
  - A client can be either in one of the following states:
1. Idle – waiting for other clients to do IM
2. Busy – currently involved in an IM with another Client.
  - The Server will establish communication between the clients only if the other 
CliClient in idle state.
  - Clients involved in the IM communicate directly with each other until the session 
is completed. Once completed, they communicate back to the Server and may reach 
out directly to another client.
  - In one session, only two clients are allowed to participate, but there can be multiple 
sessions in parallel for different pairs of clients.
  - The main implementation for bringing the client threads running is inside a function 
called run() in the src/ClientHandlers.java file.
  - The messages sent are encrypted using the AES algorithm
  - We will look at the work in detail in point 5.
![image](https://user-images.githubusercontent.com/39727591/210395514-6a8d736a-a74e-4680-a82d-241c35452742.png)

### Security
  - The messages and the session keys used for authentication are all encrypted using 
the AES 128-bit algorithm.
  - The security requirements have been met in the following way:
The authentication mechanism uses using public key cryptosystem called RSA, as 
stated in the requirements.
- Client:
1. Authentication: 
The program generates a private key for the registered Clients. Now, 
the Clients has its own private key, which it will use to authenticate 
itself to the Server. The Client’s the initial connection request to the 
Server for which the Server generates a nonce to send back to the 
Client.
2. Confidentiality: 
We are using a public key cryptosystem called RSA. The nonce, when 
sent back to the Server, is encrypted with the Client’s private key 
which is only known to the Client making the transmission secure in 
case of any attack.
3. Freshness:
Every time a client must be authenticated, we will get a new session 
key, which will be only valid for a session, and once the client exits
the communication channel, the session key will expire, thus 
safeguarding it from any replay attacks. 
4. Integrity:
Using public key cryptography, we will maintain integrity as the 
corresponding private/public keys can encrypt/decrypt the message
with the added nonce first sent by the Server.
- Client-to-Server:
1. Authentication: 
The client authenticates themselves to the Server using RSA 
mechanism. The client’s private key, along with the generated nonce
sent by the Server upon a connection request, is sent back to the 
Server. Once authenticated, the Server shares a session key if both the 
requested clients are in an idle state.
2. Confidentiality: 
During authentication, all the communications between the Client and 
the Server are based on the RSA mechanism.
Encryption of the messages between the Clients and the Server after 
authentication uses the AES mechanism. The session keys are 
generated, and messages are encrypted and decrypted through the 
AES algorithm.
3. Freshness:
Each time the Client logs in, the Server generates a new session key, 
and there will be no room for any replay attacks as the Server will 
forget the session key once the Client logs out, and no attacker can use 
the replay attacks using any of the previous session keys. 
4. Integrity:
Since the session key is only known to the Server and Client, there 
can be no alteration in the message during the transmission, thus 
ensuring the integrity of the communication. 
- Client-to-Client:
1. Authentication: 
The Client have authenticated themselves to the Server and are ready 
for direct communication. 
2. Confidentiality: 
Same as the above section, since we use public key cryptography, the 
tokens can only be decrypted by the two clients. Once establishing the 
session, the two clients only know the secret key, and message 
confidentiality is maintained. 
3. Freshness:
 Each time a client creates a new session, the Server generates a secret 
key for the clients. Since this secret key is generated randomly by the 
Server, there is no chance of replay attacks. We will use secret keys 
to ensure that if one of the clients logs out, the other Client knows of 
the session expiry. 
4. Integrity: 
Encryption of all the messages will be done using the secret key 
known to the two clients, thus saving the integrity of the 
communication.

## Working on the IM

Here is the system architecture design for our project implementation. We shall look at it 
step-by-step with running commands to understand it better

![image](https://user-images.githubusercontent.com/39727591/210396523-4b73aaa5-01f8-44db-9264-fbdaf135c2a5.png)

### Steps to do the IM:
- Step 1: Run the src/GenerateKeys.java file to generate private and public keys in 
the out/production/NetworkSecurity_ProjectIM Folder.
- Step 2: Start the Server by running the /src/Server.java file. This will make our 
Server up and running. Server is now waiting for a Client request.
- Step 3: Start a Client by running /src/Client.java . It will ask you to enter a 
username. After entering it will send a connection request to the Server.

Client-side:
![image](https://user-images.githubusercontent.com/39727591/210396973-956fe9fe-4f02-4fdb-a9ed-c1e853ddb172.png)


Server Side:
![image](https://user-images.githubusercontent.com/39727591/210396990-a6619c77-a2fe-403f-bf8b-09902f150b24.png)

The Client Aishwarya, first sent out a connection request to the Server “New client is connected.”

The Server sent out a nonce 7658534 to the Client  “Sending nonce7658534”

The Client on receiving the nonce sent out the nonce back to the Server
encrypted with its private key, “VZv1nherlzf7jJPPPvHSPQ6cK1O/cQeS4LrKMIkLjU1Fo7QOBarAsoiobuUyCVYx
iq5FnTtJI03z/tE5j1JjQihO2wBckihUSI2uKw0Nt0dWQ4pIdh1aiyAgFPQEnSPqb
OFJZj+66KoN3IWUpDz3knVO4iS5zu7qyHxSPWenfOg=”

The sever successfully authenticated the Client it was able to decrypt the 
nonce – “Decrypted message is 7658534”

- Step 4: Now Authentication for one Client is successful. Let’s do the same for 
another Client – Vaibhav, by running another instance of the Client.java file. You 
will see a new message on Server Side that says – “New client is connected.”

Client Side:
![image](https://user-images.githubusercontent.com/39727591/210397034-0082e7d1-ac2d-41b6-bf62-c840dc073bc1.png)

Server Side:
![image](https://user-images.githubusercontent.com/39727591/210397061-5414578c-62c6-4e94-ad01-70b0fe9482d6.png)

- Step 5: There is a list of commands that we can run to start the IM. 
![image](https://user-images.githubusercontent.com/39727591/210397100-8fc81bfd-5636-4ea1-a3e2-92247181bdda.png)

1. By running the first command list, we can see the list of available users in 
the pool -> [Aishwarya, Vaibhav]
2. Now to connect from client Aishwarya to Vaibhav, we should run the 
second command - > connect client2_name, i.e., connect Vaibhav.

- Step 6: After we run the second command, the Server shares a secret session key 
with both clients, and now we establish a direct communication link between the 
two clients. 

Server Side:
![image](https://user-images.githubusercontent.com/39727591/210397152-52dc572e-a525-4a50-83c1-06272c18c499.png)

Client1 (Aishwarya) side:
![image](https://user-images.githubusercontent.com/39727591/210397165-3bed8623-1837-449c-93d5-0bc3523a6ec0.png)

Client2 (Vaibhav) side:
![image](https://user-images.githubusercontent.com/39727591/210397183-e872df1d-c53d-4ea2-9b89-dafa92077ca6.png)

- Step 7: We are now all set to start the IM. Let’s send a message Hi from Client 1 
to Client 2 and one from Client 2 to client 1.

Client 1 (Aishwarya) side:
![image](https://user-images.githubusercontent.com/39727591/210397228-9b467a16-7827-4d12-bdfa-b350ccce48d3.png)

Client 2 (Vaibhav) side:
![image](https://user-images.githubusercontent.com/39727591/210397258-8502a03e-3daf-4347-9d4b-ec4c8d430ba3.png)

- Step 8: We have now successfully established direct communication from Client
to Client. Now if one of the Client wants to exit the session, they can simply type 
the keyword bye in the CLI and return back to the Server.
Here, Client1 has entered bye in the chat to exit.

Client 1(Aishwarya) side:
![image](https://user-images.githubusercontent.com/39727591/210397316-a39d3caa-80fa-4629-a94b-5913a2c1e6b0.png)

Client2 (Vaibhav) side:
![image](https://user-images.githubusercontent.com/39727591/210397342-d67fad50-42d7-4149-935d-ef1c0aed7f8c.png)

The clients are back in the pool and can connect again if they need to chat.
This is how our IM system works!!
We can also have multiple client sessions running in parallel. We can follow the same steps to run 
another session and check the client pool by running the command list on any Client’s interface.
E.g., 1: A new client3, Sahil, sends a connection request to Client1, Aishwarya, and the server 
checks if the Client is busy or not. In this case, let’s say, Aishwarya is already in an IM session 
with Vaibhav. The connection request will fail.

![image](https://user-images.githubusercontent.com/39727591/210397440-665adbb2-e64d-476a-80e4-b6ea0775ec96.png)

## Results

This is how we have built our IM system. To conclude, overall security has been achieved through
the following:
- Authentication: We have used the public key cryptography and RSA mechanism to achieve 
authentication in the system. The private keys generated are only known to the Client the 
nonce sent by the Serveris encrypted with the Client’s private key and sent back to the Server,
which can simply decrypt it using that Client’s public key, thereby achieving successful 
authentication.
- Confidentiality: The private keys generated are only known to the Client. The transmission of 
the nonce along with the encrypted private key will be safe for the Server to decode. The 
messages during client communication are also AES 128 but encrypted with a unique session 
key.
- Integrity: Encryption of all the messages will be done using the secret session key known to 
the two clients using the AES algorithm, thus saving the integrity of the communication. 
- Freshness: For every new session between the clients, a new session key is generated. Since 
the session key is randomly generated by the Server, the channel is secure against replay 
attacks if a client logs out, the other Client is intimated about the expiry of the session with a 
message saying that the Client left the chat.
